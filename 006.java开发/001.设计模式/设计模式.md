> 在软件工程中，设计模式(design pattern) 是对软件设计中普遍存在(反复出现)的各种问题，所提出的解决方案。
>
> 设计模式包含了面向对象的精髓，懂了设计模式就懂了面相对象分析和设计的精髓。

https://www.bilibili.com/video/BV1G4411c7N4/



# 1、何时会用到设计模式

**设计模式的重要性**

* 拿实际工作经历来说,当一个项目开发完后，如果客户提出增新功能，怎么办?。
* 如果项目开发完后，原来程序员离职，你接手维护该项目怎么办?(维护性[可读性规范)
* 目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中使用过什么设计模式，怎样使用的，解决了什么问题？
* 设计模式在软件中哪里?
* 如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的。



# 2、设计模式的目的

编写软件的过程中，程序员面临着来自耦合性、内聚性、可维护性、可拓展性、重用性、灵活性 等多方面的挑战，设计模式是为了让程序(软件)具有更好的：

* 代码复用性：一次编写到处使用。
* 可读性：便于同行理解。
* 可扩展性：新增新功能，非常方便。
* 可靠性：代码运行有保障，错误率低，且新增或者减少一个功能后不会影响原有功能。
* 使程序呈现高内聚、低耦合的特性。模块内部代码紧凑，模块与模块依赖性低。



# 3、设计模式的七大设计原则

设计模式原则其实就是程序员在编写代码时应当遵守的原则，也是各种设计模式的基础，即这种设计模式为什么这样设计。

* 单一职责原则
* 接口隔离原则
* 依赖倒转原则
* 里氏替换原则
* 开闭原则
* 迪米特法则
* 合成复用原则。



# 4、单一职责原则

**英译**
(Single Responsiblitity Principle)

**什么是单一职责原则**
一个类只应该负责一项业务职责，不应但掺杂其它业务，如一个类管**订单管理**，那就不要有**用户管理**相关的业务。

**单一职责原则的目的**
1、降低类的复杂度，一个类只维护一项职责。
2、提高类的可读性，可维护性。
3、降低变更带来的风险。
4、通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单时，才可以在代码级别违反单一职责原则。只有类中方法数量足够少，才可以在方法级别保持单一职责原则。



# 5、接口隔离原则

**英译**
(Interface Segregation Principle)

**什么是接口隔离原则**
接口的实现类应该只呈现为单一职责的角色（遵循 SRP 原则），实现类不应被强迫实现一些它不会使用到的接口，应该把胖接口中的方法分组，然后用多个接口替代它，每个接口服务于一个子模块。如项目经理和程序员都属于员工，程序员需要写代码，项目经理需要管理项目；因此不应当强制项目经理管理项目的同时经理去写代码，不应当让程序员写代码的同时管理项目。应此应当将写代码、管理项目两个行为抽取为两个不同接口。

**接口隔离原则的目的**
1、定义了一种接口之间相互隔离的标准，接口的粒度更小、定义更具体。
2、以调用者的使用方式为切入点，将系统解耦，使其更易于重构、更新和部署。



# 6、依赖倒转原则

**英译**
(Dependence Inversion Principle)

**什么是依赖倒转原则**
1、高层模块不应依赖于低层模块，二者都应当依赖其抽象，不要去依赖一个具体的子类。
2、抽象不应依赖细节，细节应当依赖抽象。
3、依赖倒转的中心思想是面向接口编程。
4、遵循里氏替换原则。

**依赖关系传递的三种方式**

* 接口传递
* 构造器传递
* setter传递

**依赖倒转原则的目的**
1、面向接口编程，低层模块尽量都有抽象类或者接口，增强程序的稳定性，以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，依赖倒转原则就是如此的设计理念。
2、变量的声明尽量是接口或者抽象类，【引用】和【对象】之间有一层缓冲，便于扩展和优化。



# 7、里氏替换原则

**英译**
(Liskov Substitution Principle)

**OO中的继承性的思考**
1、继承包含这样一层定义：父类凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制所有的子类必须遵循这写契约，但若子类对这些方法进行随意修改，就会对整个继承体系造成破坏。
2、继承给程序带来便利的同时，也该程序带来侵入性，程序可移植性降低，增加对象之间的耦合性，若父类需要作出修改，则需要考虑到所有子类是否会有影响。
3、编程中，如何正确使用继承？【里氏替换原则】

**什么是里氏替换原则**
1、所有引用基类的地方必须能够透明的使用其子类的对象。
2、在使用继承中，尽量不要重写父类的方法。
3、在适当情况下，可以使用【聚合、组合、依赖】来解决继承中耦合性增强的问题。

**里氏替换原则的目的**
1、约束继承泛滥，是开闭原则的一种体现。
2、增加程序的健壮性，变更时可以做到很好的兼容，提高程序的可扩展性和维护性，降低需求变更时引入的风险。



# 8、开闭原则

**英译**
(Open Closed Principle)

**什么是开闭原则**
1、开闭原则是编程中最基础、最重要的设计原则。
2、一个原件实体如类，模块和函数应当对扩展开放(对提供方)，对修改关闭(对使用方)，用抽象构建框架，用实现扩展细节。
3、当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码实现。
4、编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

**开闭原则的目的**
1、提高代码复用性，因为对修改关闭，也就是说工作的逻辑代码高度集中且基本不会改变，这部分代码就可以拿来复用，这也是封装的目的之一。
2、提高可维护性，遵循开闭原则的一个结果就是每次的修改都不会影响之前的代码，维护人员只需把精力放在本次扩展的代码上。
3、提高软件的安全性、稳定性，每次修改都不会对已有功能造成影响，确保了安全性，同时也保证了原有功能的稳定性。



# 9、迪米特法则

**英译**
(Law of Demeter)又称最少只是原则(The Least Knowledge Principle)

**什么是迪米特法则**
1、每个自身依赖的类知道的越少越好。
2、**只和直接的朋友通信**，出现在【成员变量、方法的输入输出参数】中的类就是类的直接朋友，只出现在方法体内的类就是陌生人，其违反迪米特法则。

**迪米特法则的目的**
在于降低类之间的耦合性，只是降低，并不要求完全没有依赖关系。



# 10、合成复用原则

**英译**
(Composite Reuse Principle)

**什么是合成复用原则**
尽量使用合成/聚合的关系，而不是继承。

**合成复用原则的目的**
降低类与类之间的耦合性。



# 11、设计原则的核心思想

1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2、面向接口编程，而不是面向实现编程。
3、为了交互对象之间的松耦合设计而努力。



# 12、掌握设计模式的层次

第一层：刚开始学习编程，听说过。
第二层：有很长时间的编程经验，自己写了很多代码，其中用到设计模式，但自己不知道。
第三层：学过了设计模式，发现自己已经在使用了，并发现了一些新的模式挺好用的。
第四层：阅读了很多别人写的框架和源码，在其中看别人的设计模式，并且能够领会到设计模式的精妙和带来的好处。
第五种：代码写着写着，自己都没意识到使用了设计模式，但是已经能够熟练的写出来。

设计模式不是站在功能的角度思考问题，而是站在软件系统架构的角度考虑的。



# 13、设计模式概述

1、设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案。设计模式(Design pattern)代表了最佳的实践。这些解决方案是众多软件开发人员经相当长一段时间的经验和试错总结出来的。
2、设计模式的本质是提高软件的维护性、通用性、扩展性，并降低软件的复杂度。
3、<<设计模式>>是经典的书籍。
4、设计模式并不局限于某种语言，java、php、c++都有设计模式。



# 14、设计模式类型

设计模式分文三种类型，共23种
1、创建型模式：单例、抽象工厂、原型、建造者、工厂。
2、结构型模式：适配器、桥接、装饰、组合、外观、享元、代理。
3、行为型模式：模板方法、命令、访问者、迭代器、观察者、中介者、备忘录、解释器(Interpreter)、状态、策略、职责链(责任链)。



# 15、单例模式

**什么是单例模式**
就是采取一定的方法保证整个软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法(静态方法)。
即：
1、构造私有。
2、以静态方法或者枚举返回实例。
3、确保实例只有一个，尤其是多线程环境。
4、确保反序列化时不会重新构建对象。

**单例模式举例**
JDK源码中的 Runtime类，就是使用的饿汉式单例模式。

**实现单例模式的方式**
1、饿汉式(静态常量)
2、饿汉式(静态代码块)
3、懒汉式(线程不安全)
4、懒汉式(线程安全，同步方法)
5、懒汉式(线程安全，同步代码块)
6、双重检查
7、静态内部类
8、枚举



# 16、单例-饿汉式(静态常量)

```java
package singleton.hungry_han_style.type01;

public class SingletonType01 {
    public static void main(String[] args) {
        //Test
        final Singleton instance1 = Singleton.getInstance();
        final Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2); //true
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

//饿汉式(静态常量)
class Singleton{

    //1、私有化构造器
    private Singleton(){
    }

    //2、本类内部创建对象实例
    private static final Singleton instance = new Singleton();

    //3、对外提供公有方法返回实例对象
    public static Singleton getInstance(){
        return instance;
    }
}
```

**优点**
1、写法简单，线程安全，虚拟机保证类只会装载一次，在装载类的时候是不会发生并发的，实例化过程放在成员变量处。
2、总是认为程序中会使用到这个实例，装载完成后，即可完成调用，以空间换时间，执行效率高。

**缺点**
类装载时即完成实例化，没有达到Lazy Loading的效果，若从始至终都未使用该类，则会造成内存浪费。

**结论**
这种单例模式可以用，但会造成内存浪费



# 17、单例-饿汉式(静态代码块)

```java
package singleton.hungry_han_style.type02;

public class SingletonType02 {

    public static void main(String[] args) {
        //Test
        final Singleton instance1 = Singleton.getInstance();
        final Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2); //true
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

//饿汉式(静态代码块)
class Singleton{

    //1、私有化构造器
    private Singleton(){
    }

    //2、本类内部创建对象实例
    private static final Singleton instance;

    //3、在静态代码块中创建单例对象
    static {
        instance = new Singleton();
    }

    //4、对外提供公有方法返回实例对象
    public static Singleton getInstance(){
        return instance;
    }
}
```

**优点**
1、写法简单，线程安全，虚拟机保证类只会装载一次，在装载类的时候是不会发生并发的，实例化过程放在静态代码块中。
2、总是认为程序中会使用到这个实例，装载完成后，即可完成调用，以空间换时间，执行效率高。

**缺点**
类装载时即完成实例化，没有达到Lazy Loading的效果，若从始至终都未使用该类，则会造成内存浪费。

**结论**
这种单例模式可以用，但会造成内存浪费



# 18、单例-懒汉式(线程不安全)

```java
package singleton.sluggard_style.type03;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class SingletonType03 {
    static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Set<Integer> singletons = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                Singleton instance = Singleton.getInstance();
                lock.lock();
                singletons.add(instance.hashCode());
                lock.unlock();
            }).start();
        }
        System.out.println(singletons.size());
        for (Integer singleton : singletons) {
            System.out.println(singleton);
        }
    }
}

//懒汉式(线程不安全)
class Singleton{
    //1、实例引用私有化
    private static Singleton instance;

    //2、私有化构造器
    private Singleton(){
    }

    //3、提供一个静态的公有方法,当使用到该方法时,才去创建实例
    public static Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

**优点**
起到了lazy loading 的效果，使用到再装载，以时间换空间。

**缺点**
只能在单线程中，条件判断处未加锁，多线程环境下会造成线程持有不同的对象实例。

**结论**
懒加载、线程不安全、效率高。



# 19、单例-懒汉式(线程安全，同步方法)

```java
package singleton.sluggard_style.type04;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class SingletonType04 {
    static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Set<Integer> singletons = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                Singleton instance = Singleton.getInstance();
                lock.lock();
                singletons.add(instance.hashCode());
                lock.unlock();
            }).start();
        }
        System.out.println(singletons.size());
        for (Integer singleton : singletons) {
            System.out.println(singleton);
        }
    }
}

//懒汉式(线程安全，同步方法)
class Singleton{
    //1、实例引用私有化
    private static Singleton instance;

    //2、私有化构造器
    private Singleton(){
    }

    //3、提供一个静态的公有方法,当使用到该方法时,才去创建实例
    public synchronized static Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

**优点**
1、起到了lazy loading 的效果，使用到再装载，以时间换空间。
2、在方法上加锁，线程安全。

**缺点**
效率太低，在类实例化过后，多线程环境下多个线程每次调用getInstance()方法时都要进行同步。

**结论**
懒加载、线程安全、效率低。



# 20、单例-懒汉式(线程安全，同步代码块)

```java
package singleton.sluggard_style.type05;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class SingletonType05 {
    static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Set<Integer> singletons = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                Singleton instance = Singleton.getInstance();
                lock.lock();
                singletons.add(instance.hashCode());
                lock.unlock();
            }).start();
        }
        System.out.println(singletons.size());
        for (Integer singleton : singletons) {
            System.out.println(singleton);
        }
    }
}

//懒汉式(线程安全，同步代码块)
class Singleton{
    //1、实例引用私有化
    private static Singleton instance;

    //2、私有化构造器
    private Singleton(){
    }

    //3、提供一个静态的公有方法,当使用到该方法时,才去创建实例
    public static Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                instance = new Singleton();
            }
        }
        return instance;
    }
}
```

**优点**
起到了lazy loading 的效果，使用到再装载，以时间换空间。

**缺点**
加锁的地方毫无意义，锁住的是创建对象的过程，而不是判断的过程，仍会造成并发问题。

**结论**
不可用，实际开发中，不要使用这种方式。



# 21、单例-双重检查(double check)

```java
package singleton.double_check;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class SingletonType06 {

    static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Set<Integer> singletons = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                Singleton instance = Singleton.getInstance();
                lock.lock();
                singletons.add(instance.hashCode());
                lock.unlock();
            }).start();
        }
        System.out.println(singletons.size());
        for (Integer singleton : singletons) {
            System.out.println(singleton);
        }
    }
}

//单例-双重检查(double check)
class Singleton{
    //1、实例引用私有化
    private static volatile Singleton instance;

    //2、私有化构造器
    private Singleton(){
    }

    //3、提供一个静态的公有方法,当使用到该方法时,才去创建实例
    public static Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**优点**
1、起到了lazy loading 的效果，使用到再装载，以时间换空间。
2、使用双重检查的方式，外层判断保证了非并发的效率问题，内层判断加锁结合volatile关键字保证线程安全，并解决了多线程数据不一致问题，实际volatile是以轻量级锁替换synchronized的重量级锁，是为了提高效率。

**缺点**
无任何缺点

**结论**
懒加载、线程安全、效率高。



# 22、单例-静态内部类

```java
package singleton.static_inner_class;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class SingletonType07 {

    static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Set<Integer> singletons = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                Singleton instance = Singleton.getInstance();
                lock.lock();
                singletons.add(instance.hashCode());
                lock.unlock();
            }).start();
        }
        System.out.println(singletons.size());
        for (Integer singleton : singletons) {
            System.out.println(singleton);
        }
    }
}

//单例-双重检查(double check)
class Singleton{
    //1、私有化构造器
    private Singleton(){
    }

    //2、创建静态内部类,静态内部类内部类中维护一个静态的Singleton类型的实例
    private static final class SingletonInstance{
        private static final Singleton INSTANCE = new Singleton();
    }

    //3、提供公共的get方法获取实例
    public static Singleton getInstance(){
        return SingletonInstance.INSTANCE;
    }
}
```

**优点**
1、起到了lazy loading 的效果，外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，以时间换空间。
2、使用时装载静态内部类实例，JVM在装载类时是不会发生并发的，保证了线程安全。

**缺点**
无任何缺点

**结论**
懒加载、线程安全、效率高。

**深入理解静态内部类实现单例模式**

> 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。
> 即：

1、当Singleton类第一次被加载时，并不需要加载SingletonInstance类。
2、只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE。
3、第一次调用getInstance()方法会导致虚拟机加载SingletonInstance类。
4、这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。

> 那么，静态内部类又是如何实现线程安全的呢？首先，先了解下类的加载时机。
> **类加载时机**：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化：

1、遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时；对应的java代码场景为：
【new一个关键字或者一个实例化对象时】、
【读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)】、
【调用一个类的静态方法时】；
2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。
3、当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。
4、当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。
5、当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是"有且仅有"，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。

> 我们再回头看下getInstance()方法

调用的是SingletonInstance.INSTANCE，取的是SingletonInstance里的INSTANCE对象，跟上面那个DCL(double check lock)方法不同的是,getInstance()方法并没有多次去new对象，故不管多少个线程去调用getInstance()方法，取的都是同一个INSTANCE对象，而不用去重新创建。当getInstance()方法被调用时，SingletonInstance在SingleTon的运行时常量池里，把符号引用替换为直接引用，这时静态对象INSTANCE也真正被创建，然后再被getInstance()方法返回出去，这点同饿汉模式。

> 那么INSTANCE在创建过程中又是如何保证线程安全的呢？

在《深入理解JAVA虚拟机》中，有这么一句话:
虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。如果在一个类的`<clinit>()`方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行`<clinit>()`方法后，其他线程唤醒之后不会再次进入`<clinit>()`方法。同一个加载器下，一个类型只会初始化一次。在实际应用中，这种阻塞往往是很隐蔽的。

故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。

那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL(double check lock)模式里自己斟酌。



# 23、单例-枚举

```java
package singleton.enum_class;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class SingletonType8 {

    static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Set<Integer> singletons = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                Singleton instance = Singleton.INSTANCE;
                lock.lock();
                singletons.add(instance.hashCode());
                lock.unlock();
            }).start();
        }
        System.out.println(singletons.size());
        for (Integer singleton : singletons) {
            System.out.println(singleton);
        }
    }
}

//单例-枚举
enum Singleton{
    INSTANCE;
    public void sayOk(){
        System.out.println("ok");
    }
}
```

**优点**
1、写法简洁，代码短小精悍，可读性好。
2、线程安全。
3、防止反序列化和反射的破坏。

**缺点**
1、个人理解是饿汉式，没有达到Lazy Loading的效果，若从始至终都未使用该类，则会造成内存浪费。
2、枚举会比一般的类更加占内存。

**结论**
线程安全、效率高、防止反序列化破和反射的破环，推荐使用。

**关于枚举的理解和最佳实践**
1、枚举的实现原理就是定义一个类，然后实例化几个由final修饰的这个类的对象，每个实例都带有自己的元信息。
2、而常量相比之下，没有这一层封装，只占用最基本的内存，包括引用，和它的值本身，要简单轻巧很多。如果值可以使用基本类型而不是包装类型，那更不用说了。
3、不过话又说回来，通常情况下我们没必要在意这种区别。如果用枚举可读性、可扩展性更好，用就是了，枚举占那点内存，沧海一粟。在性能与代码维护性之间，除个别情况，优先选后者。高级编程语言的诞生本身就是硬件提升的背景下，牺牲某些性能来降低开发门槛，提高开发效率的，相对于微小的性能损耗，人力成本更值钱。



# 24、为什么枚举是单列模式最佳实践

在单例模式的实践中，除去枚举实现的单例模式，其它的实现都可以利用反射构造新对象，从而破坏单例模式。
破坏单例的方式有 3 种，反射、克隆以及序列化：

## 1、反射

**1、常见的单例模式实现中，往往有一个私有的构造函数，防止外部程序的调用，但是通过反射可以轻而易举的破坏这个限制：**

```java
package destroy.double_check;


import java.lang.reflect.Constructor;

public class SingletonDestroy {
    public static void main(String[] args) throws Exception{
        final Singleton instance = Singleton.getInstance();
        final Constructor<Singleton> declaredConstructor = Singleton.class.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        final Singleton singleton = declaredConstructor.newInstance();
        System.out.println(singleton == instance);
    }
}

//单例-双重检查
class Singleton{
    private static volatile Singleton instance;

    private Singleton(){
    }

    public static Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**2、通过反射获取枚举对象之前，我们需要先看一下`Construtor的newInstance(Object … initargs)`方法中的一段源码**

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230306180415355.png" alt="image-20230306180415355" style="zoom:67%;" />

**3、由newInstance方法的源码可知，反射在通过newInstance方法创建对象时，会先检查该类是否是枚举类，如果是，则会抛出IllegalArgumentException(“Cannot reflectively create enum objects”)异常，导致使用反射创建对象失败，测试一下：**

```java
package destroy.enum_class;

import java.lang.reflect.Constructor;

public enum SingletonDestroy {
    INSTANCE;

    public static void main(String[] args) throws Exception{
        final Constructor<SingletonDestroy> declaredConstructor = SingletonDestroy.class.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        final SingletonDestroy singleton = declaredConstructor.newInstance();
        System.out.println(SingletonDestroy.INSTANCE == singleton);
    }
}

```

![image-20230306173232000](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230306173232000.png)

如上图，由运行抛出的异常可知，并不是我们预期的newInstance方法中的IllegalArgumentException(“Cannot reflectively create enum objects”)异常，而是NoSuchMethodException异常，说明枚举类中并没有无参构造函数，编译后的源码欺骗了我们。
**4、通过javap来反编译看一下枚举类的源码。**

```java
PS E:\project\study\designPattern\target\classes\destroy\enum_class> javap -p .\SingletonDestroy.class
Compiled from "SingletonDestroy.java"
public final class destroy.enum_class.SingletonDestroy extends java.lang.Enum<destroy.enum_class.SingletonDestroy> {
  public static final destroy.enum_class.SingletonDestroy INSTANCE;
  private static final destroy.enum_class.SingletonDestroy[] $VALUES;
  public static destroy.enum_class.SingletonDestroy[] values();
  public static destroy.enum_class.SingletonDestroy valueOf(java.lang.String);
  private destroy.enum_class.SingletonDestroy();
  public static void main(java.lang.String[]) throws java.lang.Exception;
  static {};
}
PS E:\project\study\designPattern\target\classes\destroy\enum_class>
```

如上结果`private destroy.enum_class.SingletonDestroy();`反编译后的枚举类中存在的仍是无参构造，说明反编译后的代码仍然骗了我们。
**5、下面我们就使用更专业的工具jad来进行反编译。**

> jad下载：http://www.javadecompilers.com/jad
> jad安装：https://www.cnblogs.com/chandol/p/16670001.html

```java
PS E:\project\study\designPattern\target\classes\destroy\enum_class> jad .\SingletonDestroy.class
Parsing .\SingletonDestroy.class... Generating SingletonDestroy.jad
PS E:\project\study\designPattern\target\classes\destroy\enum_class> cat .\SingletonDestroy.jad
// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3)
// Source File Name:   SingletonDestroy.java

package destroy.enum_class;

import java.io.PrintStream;
import java.lang.reflect.Constructor;

public final class SingletonDestroy extends Enum
{

    public static SingletonDestroy[] values()
    {
        return (SingletonDestroy[])$VALUES.clone();
    }

    public static SingletonDestroy valueOf(String name)
    {
        return (SingletonDestroy)Enum.valueOf(destroy/enum_class/SingletonDestroy, name);
    }

    private SingletonDestroy(String s, int i)
    {
        super(s, i);
    }

    public static void main(String args[])
        throws Exception
    {
        Constructor declaredConstructor = destroy/enum_class/SingletonDestroy.getDeclaredConstructor(new Class[0]);
        declaredConstructor.setAccessible(true);
        SingletonDestroy singleton = (SingletonDestroy)declaredConstructor.newInstance(new Object[0]);
        System.out.println(INSTANCE == singleton);
    }

    public static final SingletonDestroy INSTANCE;
    private static final SingletonDestroy $VALUES[];

    static
    {
        INSTANCE = new SingletonDestroy("INSTANCE", 0);
        $VALUES = (new SingletonDestroy[] {
            INSTANCE
        });
    }
}
```

由jad反编译后的源码可知，枚举类的构造函数为有参构造函数 EnumSingle(String s, int i)，并且有两个参数。<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230306194909937.png" alt="image-20230306194909937" style="zoom:67%;" />

下面我们就使用反射获取枚举类的有参构造函数，看使用反射是否能创建新的实例对象。

```java
package destroy.enum_class;

import java.lang.reflect.Constructor;

public enum SingletonDestroy {
    INSTANCE;

    public static void main(String[] args) throws Exception{
        final Constructor<SingletonDestroy> declaredConstructor = SingletonDestroy.class.getDeclaredConstructor(String.class, int.class);
        declaredConstructor.setAccessible(true);
        final SingletonDestroy singleton = declaredConstructor.newInstance("test", 1);
        System.out.println(SingletonDestroy.INSTANCE == singleton);
    }
}
```

![image-20230306195128336](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230306195128336.png)

由运行结果可知，与我们预期的异常一样，抛出了IllegalArgumentException(“Cannot reflectively create enum objects”)异常。
此时说明使用枚举类实现单例模式是十分安全的，使用反射进行暴力破解也不能创建新的对象。

## 2、序列化

先看看通过序列化破坏单例的例子，其中 Singleton 实现了 Serializable 接口，才有可能通过序列化破坏单例。

```java
package serialize;

import java.io.*;

public class DoubleCheckLockSerialize{
    public static void main(String[] args) throws Exception {
        final Singleton instance = Singleton.getInstance();
        try (final ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("Singleton.obj"))) {
            oos.writeObject(instance);
        }

        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("Singleton.obj"))){
            Singleton s2 = (Singleton) ois.readObject();
            System.out.println(instance == s2);//false 单例被破环
        }

    }

}

class Singleton implements Serializable{
    private static volatile Singleton INSTANCE;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

枚举类实现，枚举类不实现 Serializable 接口，都可以进行序列化，并且返回原来的单例。

```java
package serialize;

import java.io.*;

public enum EnumSerialize {
    INSTANCE;

    public static void main(String[] args) throws Exception{
        final EnumSerialize instance = EnumSerialize.INSTANCE;
        try (final ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("Singleton.obj"))){
            oos.writeObject(instance);
        }
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("Singleton.obj"))){
            EnumSerialize e2 = (EnumSerialize) ois.readObject();
            System.out.println(instance == e2);//true //
        }
    }
}
```

因为：枚举类的 writeObject 方法仅仅是将 Enum.name 写到文件中，反序列化时，根据 readObject 方法的源码定位到 Enum 的 valueOf 方法，他会根据名称返回原来的对象。

## 3、克隆

实现 Cloneable 接口重写 clone 方法，但是 Enum 类中 clone 的方法是 final 类型，无法重写，也就不能通过克隆破坏单例。

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230307091042014.png" alt="image-20230307091042014" style="zoom:80%;" />

Enum类中的clone()方法是final类型的，不可重写。



## 4、防止普通类单例模式被破坏

1、若实现了序列化接口，重写readResolve方法即可，反序列化时将调用该方法返回对象实例。

```java
package serialize;

import java.io.*;

public class DoubleCheckLockSerialize{
    public static void main(String[] args) throws Exception {
        final Singleton instance = Singleton.getInstance();
        try (final ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("Singleton.obj"))) {
            oos.writeObject(instance);
        }

        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("Singleton.obj"))){
            Singleton s2 = (Singleton) ois.readObject();
            System.out.println(instance == s2);//true
        }

    }

}

class Singleton implements Serializable{
    private static volatile Singleton INSTANCE;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }

    /**
     * readResolve 用于维护单例行为,如果类实现了反序列化接口,并重写了readResolve()方法时
     * JVM会调用类的readResolve()方法获取对象
     */
    private Object readResolve() throws ObjectStreamException {
        return getInstance();
    }
}
```

2、通过反射破坏单例的场景，可以在构造方法中判断实例是否已经创建，若已创建则抛出异常

```java
package serialize;

import javax.management.InstanceAlreadyExistsException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class DoubleCheckLockReflect {
    public static void main(String[] args) throws Exception{

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    Constructor<Singleton02> declaredConstructor = Singleton02.class.getDeclaredConstructor();
                    declaredConstructor.setAccessible(true);
                    final Singleton02 singleton02 = declaredConstructor.newInstance();
                    System.out.println("反射创建"+singleton02.hashCode());
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                } catch (NoSuchMethodException e){
                    e.printStackTrace();
                }
            }).start();
        }

        new Thread(() -> {
            try {
                final Singleton02 instance = Singleton02.getInstance();
                System.out.println("getInstance"+instance.hashCode());
            } catch (InstanceAlreadyExistsException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

class Singleton02{
    private static volatile Singleton02 INSTANCE;

    private Singleton02() throws InstanceAlreadyExistsException {
//        if (INSTANCE != null){
//            throw new InstanceAlreadyExistsException("类实例已存在");
//        }
        if (INSTANCE == null){
            synchronized (Singleton02.class){
                if (INSTANCE != null){
                    throw new InstanceAlreadyExistsException("类实例已存在");
                }
            }
        } else {
            throw new InstanceAlreadyExistsException("类实例已存在");
        }

    }

    public static Singleton02 getInstance() throws InstanceAlreadyExistsException {
        if (INSTANCE == null) {
            synchronized (Singleton02.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton02();
                }
            }
        }
        return INSTANCE;
    }
}
```

但是，实际测试结果不如人意，如图，反射在前，getInstance()在后，且并发条件下，部分反射成功。
原因是反射在前获取实例时，INSTANCE变量还是未赋值的

![image-20230307100948135](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230307100948135.png)

那么如何修改呢？构造函数如下写即可

```java
if (INSTANCE != null){
	throw new InstanceAlreadyExistsException("类实例已存在");
} else {
	INSTANCE = this;
}
```

但是会有并发问题。通过双检锁再改

```java
        if (INSTANCE == null){
            synchronized (Singleton02.class){
                if (INSTANCE == null){
                    INSTANCE = this;
                }else {
                    throw new InstanceAlreadyExistsException("类实例已存在");
                }
            }
        } else {
            throw new InstanceAlreadyExistsException("类实例已存在");
        }
```

如下，最终结构：

```java
package serialize;

import javax.management.InstanceAlreadyExistsException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class DoubleCheckLockReflect {
    public static void main(String[] args) throws Exception{
        Thread.sleep(1000);
        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                try {
                    Constructor<Singleton02> declaredConstructor = Singleton02.class.getDeclaredConstructor();
                    declaredConstructor.setAccessible(true);
                    final Singleton02 singleton02 = declaredConstructor.newInstance();
                    System.out.println("反射创建"+singleton02.hashCode());
                } catch (InstantiationException e) {
//                    e.printStackTrace();
                } catch (IllegalAccessException e) {
//                    e.printStackTrace();
                } catch (InvocationTargetException e) {
//                    e.printStackTrace();
                } catch (NoSuchMethodException e){
//                    e.printStackTrace();
                }
            }).start();
        }

        new Thread(() -> {
            try {
                final Singleton02 instance = Singleton02.getInstance();
                System.out.println("getInstance"+instance.hashCode());
            } catch (InstanceAlreadyExistsException e) {
//                e.printStackTrace();
            }
        }).start();
    }
}

class Singleton02{
    private static volatile Singleton02 INSTANCE;

    private Singleton02() throws InstanceAlreadyExistsException {
        if (INSTANCE == null){
            synchronized (Singleton02.class){
                if (INSTANCE == null){
                    INSTANCE = this;
                }else {
                    throw new InstanceAlreadyExistsException("类实例已存在");
                }
            }
        } else {
            throw new InstanceAlreadyExistsException("类实例已存在");
        }

    }

    public static Singleton02 getInstance() throws InstanceAlreadyExistsException {
        if (INSTANCE == null) {
            synchronized (Singleton02.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton02();
                }
            }
        }
        return INSTANCE;
    }
}
```

3、普通类重写 clone 方法，返回已有单例对象



# 25、单例模式注意事项和细节

1、单例模式保证了系统中该类只有一个对象，节省系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高性能。
2、当想实例化一个单例类时，必须要使用相应的获取对象的方法，而不是new。
3、单例模式使用的场景：【频繁进行创建销毁的对象、创建对象耗时较长或耗资源较多(即重量级对象)但又经常使用的对象、工具类对象、频繁访问数据库或文件资源的对象(如数据源、Session工厂等)】。



# 26、工厂模式

**英译**
(Factory Pattern)

**概述**
工厂模式是属于创建型模式的，通过工厂获取一个一个的新对象。说白了，工厂就是用来 new（创建）对象的



# 27、简单工厂模式

**英译**
(Simple Factory Pattern)

**概述**
1、简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出那一种产品的实例。简单工厂模式是工厂模式家族中最简单实用的模式。
2、简单工厂模式：定义一个创建对象的类，由这个类来封装实例化对象的行为。
3、在软件开发中，当我们需要大量创建某种、某类、或者某批对象时，就会用到工厂模式。
4、简单工厂模式又叫做静态工厂模式，它的创建实例的方法可以写成静态的，或者一个工厂类可以同时存在两者，这是根据需求来决定的，这些没有限制。



# 28、工厂方法模式

**英译**
(Factory Method Pattern)

**概述**
定义一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将**对象的实例化推迟到子类**。



# 29、抽象工厂模式

**英译**
(Abstract Factory Pattern)

**概述**
1、定义一个接口，用于创建相关或者有依赖关系的对象簇，而无需指明具体的类。
2、抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3、从设计层面看，抽象工厂模式就是对简单工厂模式的改进（进一步抽象）。
4、将工厂抽象成两层，Abstract(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂变成了工厂簇，更利于代码的维护和扩展。



# 30、工厂模式在JDK的应用

```java
java.util.Calendar;
Calendar calendar = Calendar.getInstance();
```

其构造采用抽象工厂，返回实例

![image-20230310110157973](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230310110157973.png)



# 31、原型模式

**英译**
(Prototype Pattern)

**概述**
1、原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
2、原型模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建的细节。
3、工作原理是：通过将一个原型对象传给那个要发起创建的对象，这个发起创建的对象通过请求原型对象拷贝它们自己来创建对象(即对象.clone);
4、形象的理解就是 孙悟空 拔毛 变大圣。



# 32、原型模式-Spring框架的应用

> Spring 中原型 bean 的创建，就是原型模式的应用。

Spring中原型bean的创建就是原型模式的应用。



# 33、原型模式-深浅拷贝

**浅拷贝**
1、对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2、对于数据类型是引用数据类型的成员变量，比如成员变量是某个数组、某个类的对象，那么浅拷会进行引用传递，也就是只将该成员变量的引用值(内存地址值)复制给新的对象，实际上两个对象的成员变量都指向一个相同的实例，这种情况下，在一个对象中修改该成员变量会影响另一个对象的该成员变量。
3、浅拷贝使用默认的`clone()`方法来实现。

**深拷贝**
1、复制对象的所有基本数据类型的成员变量值。
2、为所有引用数据类型的成员变量申请内存空间，并复制每个引用数类型成员变量所引用的对象，知道该对象可达的所有对象。即拷贝整个对象。
3、深拷贝可以通过`重写clone()方法` 或者`对象序列化与反序列化`来实现。

```java
//对象序列化与反序列化过程
public DeepPrototype deepClone() throws Exception{
        //创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;

        //序列化  转字节流输出
        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        //反序列化
        bis = new ByteArrayInputStream(bos.toByteArray());
        ois = new ObjectInputStream(bis);

        ois.close();
        bis.close();
        oos.close();
        bos.close();

        return  (DeepPrototype)ois.readObject();
    }
```



# 34、建造者模式

**英译**
(Buildder Pattern)

**概述**
将产品建造过程解耦
1、建造者模式又叫生成器模式，是一种对象构建模式，它可以将复杂对象的构建过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。
2、建造者模式是一步步创建一个复杂的对象，它允许用户指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的构建细节。

**建造者模式的4个角色**
1、Product（产品角色）：一个具体的产品对象。
2、Builder（抽象建造者）：创建一个Product对象的各个部件指定接口。
3、ConcreteBulider（具体建造者）：实现接口，构建和装配各个部件。
4、Director（指挥者）：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象，它主要有两个作用：一是隔离了客户与对象的生产过程，二是负责控制产品对象的生产过程。

**建造者模式在JDK中的应用**

> 我们在查看源码的时候，发现一些源码的涉及并不一定和设计模式规范的类图完全一致，这是因为一是需要兼容老版本，二是设计者在编码是并不知道自己使用了这种设计模式，但是其思想是大致相同的。

StringBuilder append(String s);
AppendAble 接口定义了多个append方法(抽象)，即AppendAble为抽象建造者，定义了抽象方法。
AbstractStringBuilder 实现了 AppendAble 接口的方法，因此 AbstractStringBuilder 已经是一个建造者了，只是不能实例化。
StringBuilder 既充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 来完成的，而 StringBuilder 只是继承了他.

**建造者模式的好处**
1、客户端不需要知道产品内部的组成细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
2、每个具体建造者都相对独立，而于其它具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体建造者，用户使用不同具体建造者可以获得不同的产品对象。
3、可以更加精细的控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
4、增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合"开闭原则"。

**建造者模式的缺点**
1、建造者模式创建的产品一般具有较多的共同点，其组成部分相似，若产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受一定限制.
2、若产品内部变化复杂，可能会导致需要定义很多具体建造者来实现这种变化，导致系统变得很庞大，因此这种情况下，需要考虑是否选择建造者模式.

**抽象工厂模式VS建造者模式**
抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具体有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新的产品。



# 35、适配器模式

**英译**
(Adapter Pattern)

**概述**
适配器模式将某个类的接口转换为客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器(Wrapper)。
适配器模式属于结构性模式。
主要分为三类：
	类适配器模式：继承。
	对象适配器模式：持有，对象。
	接口适配器模式：实现。

**工作原理**
1、适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容。
2、从用户角度看不到被适配者，是解耦的。
3、用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。
4、用户收到反馈结果，感觉只是和目标接口交互。



# 36、类适配器模式

**概述**
Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。

**缺点**
1、Java是单继承机制，所以类适配器需要继承src类这一点算是个缺点，因为dst必须是一个接口，由一定局限性。
2、src类的方法在Adapter中都会暴露出来，也增加了使用成本。

**优点**
由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter类的灵活性增强了。



# 37、对象适配器模式

**概述**
1、基本思路与类适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配。
2、根据"合成复用法则"，在系统中尽量用关联关系来取代继承关系。
3、对象适配器模式是适配器模式中常用的一种。
4、对象适配器和类适配器其实算是同一种思想，只不过实现方式不同，根据合成复用原则，使用组合替代继承，解决了类适配器必须继承src的局限性，也不再要求dst必须是接口。
5、使用成本低，更灵活。



# 38、接口适配器模式

**概述**
1、也称适配器模式(Default Adapter Pattern)或缺省适配器模式。
2、当不需要实现接口的全部方法时，可以先设计一个抽象类实现接口，并为该接口中的每个方法提供一个默认实现(空方法)，那么该抽象类的子类可以有选择性的覆盖父类的某些方法来实现需求。
3、适用于一个接口不想使用其所有的方法的情况。



# 39、适配器模式再SpringMVC中的应用

1、SpringMVC中的HandlerAdapter，就使用了适配器模式。
2、在DispatcherServlet的doDispatch方法中，根据request对象获取一个Handler。
3、通过Handler获取对应的Adapter，而后做相应处理。
4、扩展controller时只需要新增一个适配器即可完成对SpringMVC的扩展了。



# 40、桥接模式

**英译**
(Bridge Pattern)

**概述**
1、桥接模式是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
2、是一种结构型设计模式。
3、Bridge模式基于类的最小设计原则，通过封装、聚合、继承 等行为让不同的类承担不同的职责。它的主要特点是将抽象与行为实现分离开来，从而可以保持各部分的独立性 以及 应对它们的功能扩展。

**优点**
1、实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。
2、对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它部分由具体业务来完成。
3、桥接模式替代了多层继承方案，可以减少子类的数量，降低系统的管理和维护成本。

**缺点**
1、桥接模式的引入，增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
2、桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。

**应用场景**
1、对于那些不希望使用继承或者因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。
2、常见运用场景如：
	-JDBC驱动程序
	-银行卡转账系统
	转账分类：网上、柜台、ATM…
	转账用户类型：普通、银卡、金卡…
	-消息管理
	消息类型：即时、延时…
	消息分类：手机短信、邮件、qq、微信…



# 41、桥接模式在JDBC源码的应用

DriverManager是一个桥 连接 Java.sql.Connection， 但是DriverManager没有具体的子类去实现它，而Connection有。



# 42、装饰者模式

**英译**
(Decorator Pattern)

**概述**
动态将新功能附加到对象上。在对象扩展方面，它比继承更加有弹性，装饰着模式也体现了开闭原则(OCP)。





# 43、装饰者模式在IO流源码的应用

FilterInputStream就是一个装饰者。
1、InputStream是抽象类，类似 Drink。
2、FileInputStream是InputStream子类，类似LongBlack。
3、FilterInputStream是InputStream子类，类似Decorator装饰者。
4、DataInputStream是FilterInputStream子类，具体的装饰者，类似Milk、Soy。
5、FilterInputStream类有 protected volatile InputStream in；即含被装饰者。
6、分析得出在jdk的io体系中，就是使用的装饰者模式。





# 44、组合模式

**英译**
(Composite Pattern)

**概述**
1、组合模式又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示"整体-部分"的层次关系。
2、组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
3、组合模式属于结构性模式。
4、组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。
5、组合模式解决这样的问题，当我们要处理的对象可以生成一个树形结构，而我们要对树上的节点和叶子节点进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子。

**好处**
1、简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者叶子节点的问题。
2、具有较强的扩展性，当我们需要更改组合对象时，只需要调整内部的层次关系，客户端不需要做任何改动。
3、方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂树形结构。
4、需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式。

**缺点**
要求较高的抽象性，若节点或者叶子具有较高的差异性的话，比如很多方法和属性都不一样，不适合使用组合模式。



# 45、组合模式在HashMap中的应用

java的集合类 HashMap 就使用了组合模式。AbstractMap实现了Map，HashMap继承AbstractMap，Node聚合进了Map。
1、Map是一个抽象的构建，类似(Component)。
2、HashMap是一个中间的构建(Composite)，实现/继承了相关方法。
3、Node是HashMap的静态内部类，类似Leaf叶子节点，就没有put、remove等方法。





# 46、外观模式

**英译**
(Facade Pattern)

**概述**
1、外观模式也叫"过程模式"，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
2、外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。

**角色**
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230327142853848.png" alt="image-20230327142853848" style="zoom:70%;" />

外观类(Facade)：为调用端提供统一的接口，它知道哪些子系统负责处理请求，从而将调用端的请求代理给适当的子系统对象。
调用者(Client)：外观接口的调用者。
子系统的集合：指模块或者子系统，处理Facade对象指派的任务，他是功能的实际提供者。

**好处**
1、外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对于子系统使用的复杂性。
2、外观模式将客户端和子系统解耦，让子系统内部的模块更容易维护和扩展。
3、通过合理的使用外观模式，可以帮我们更好的划分访问的层次。
4、当系统需要进行分层设计时，可以考虑使用Facade模式。
5、在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类进行交互，提高复用性。

**缺点**
不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用好，主要是以让系统有层次，利于维护的目的。



# 47、外观模式在Mybatis框架的应用

Mybatis中的Configuration去创建MetaObject对象使用到外观模式。



# 48、享元模式

**英译**
(Flyweight Pattern)

**概述**
1、享元模式也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象。
2、常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。
3、享元模式能够解决重复对象的内存浪费问题，当系统中有大量相似对象，需要缓冲池。不需总是创建新对象，可以从缓冲池中拿，这样可以降低系统内存，同时提高效率。
4、享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。
5、享元模式，享就是共享，元就是对象。
6、系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑使用享元模式。
7、用唯一标识码判断，如果内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储。

**原理图**
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230327175454497.png" alt="image-20230327175454497" style="zoom:67%;" />

1、FlyWeight 是抽象的享元角色，它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口实现。
外部状态：经常改变的对象 》》五子棋的棋子位置
内部状态：不常改变的对象》》五子棋的棋子颜色
2、ConcreateFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务。
3、UnSharedConcreateFlyWeight 是不共享的角色，一般不会出现在享元工厂。
4、FlyWeightFactory 享元工厂类，用于构建一个池容器(集合)，同时提供池中获取对象的方法。

**内部状态和外部状态**
1、享元模式提出了两个要求：细粒度和共享对象，这里就涉及到内部和外都状态了，即对象信息分为:内部和外部状态。
2、内部状态：指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变。
3、外部状态：指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

**好处**
1、享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率。

**坏处**
1、享元模式提高了系统的复杂度，需要分离出内部和外部状态，而外部状态具有固化性，不应随内部状态的改变而改变，这是使用享元模式需要注意的地方。
2、使用享元模式时，注意划分内部外部状态，并且需要一个工厂类加以控制。



# 49、享元模式在Integer源码中的应用

Integer中有一个缓冲池 IntegerCache，里面存放 -127 — 128 的整数常量。
Integer.valueOf(-127)即使用享元模式返回。该范围可以通过jvm参数设置。



# 50、代理模式

**英译**
(Proxy Pattern)

**概述**
1、代理模式：为对象提供一个替身，以控制这个对象的访问。即通过代理对象访问目标对象，这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
2、被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。
3、代理模式有三种不同形式：静态代理、动态代理(JDK代理、接口代理)、Cglib代理(可以在内存中动态创建对象，而不需要实现接口，它是属于动态代理的一个范畴)。

**原理图**



# 51、静态代理

**概述**
静态代理在使用时需要定义接口或父类，被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同的父类。

**优点**
在不修改目标对象功能的前提下，能够通过代理对象对目标功能扩展。

**缺点**
1、因为代理对象需要和目标对象实现一样的接口，所以会有很多代理类。
2、一旦接口增加新功能，目标对象和代理对象都需要维护。

**类图**
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230328101206969.png" alt="image-20230328101206969" style="zoom:67%;" />



# 52、动态代理

**概述**
1、代理对象不需要实现接口，但目标对象仍需要实现接口，否则不能用动态代理。
2、代理对象的生成，是利用jdk的API，动态的在内存中构建代理对象。
3、动态代理也叫JDK代理或者接口代理。

**类图**
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230328101251691.png" alt="image-20230328101251691" style="zoom:67%;" />



# 53、Cglib代理

1、静态代理和JDK代理都要求目标对象实现一个接口，但是有的时候目标对象只是一个单独的对象，并没有实现任何接口，这时可使用目标对象子类来实现代理，这就是Cglib代理。
2、Cglib代理也叫子类代理，它是内存中构建一个子类对象从而实现对目标对象功能的扩展，有些书也将Cglib代理归属到动态代理。
3、Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口，它广泛的被许多AOP的框架使用，例如SpringAOP实现方法拦截。
4、在AOP编程中如何使用代理模式：
		1、目标对象需要实现接口，用JDK代理。
		2、目标对象不需要实现接口，用Cglib代理。
5、Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类。

**类图**
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230328101500716.png" alt="image-20230328101500716" style="zoom:67%;" />



# 54、代理模式的变体

**几种常见的代理模式介绍**
1、防火墙代理
	  内网通过代理穿透防火墙，实现对公网的访问。
2、缓存代理
	  比如：当请求图片等资源，先从缓存中取出，如果缓存中没有，则去公网或者数据库中去取，然后缓存。
3、远程代理
	  远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通网络和真正的远程对象沟通信息。
4、同步代理
	  主要使用在多线程编程中，完成线程间的同步工作。



# 55、模板方法模式

**英译**
(Template Method Pattern)

**概述**
1、模板方法模式又叫模板模式，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
2、简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重新定义该算法的某些特定步骤。
3、这种类型的设计模式属于行为型模式。

**流程图**
1、AbstractClass 抽象类，实现了模板方法(template)，定义了算法的骨架，具体子类需要实现抽象方法。
2、ConcreteClass 实现抽象类中的抽象方法，以完成算法中特定子类的步骤。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230328105604198.png" alt="image-20230328105604198" style="zoom:67%;" />

# 56、模板方法模式的钩子方法

在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况选择是否覆盖，该方法为"钩子"。



# 57、模板方法在Spring-IOC中的应用

SpringIOC容器初始化的时候运用到的模板方法模式。
refresh() 方法就是一个模板方法。



# 58、命令模式

**英译**
(Command Pattern)

**概述**
1、在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，此时可以使用命令模式来进行设计。
2、命令模式使得请求发送和接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
3、在命令模式中，通常会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。
4、通俗的讲，将军发布命令，士兵执行，包含的角色为
	Invoker：调用者：命令发布者(将军)
	Receiver：被调用者：命令的具体执行者(士兵)
	MyCommond：实现Commond接口，命令(连接将军和士兵)

**原理图**
1、Invoker 是调用者角色
2、Commond：命令角色，需要执行的所有命令都在这里，可以是接口或者抽象类
3、Receiver：接收者角色，如何实施和执行一个请求相关的操作。
4、ComcreteCommand：将接收者对象与一个命令绑定，调用接收者对应的操作，实现execute。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230328132727731.png" alt="image-20230328132727731" style="zoom:67%;" />

**好处**
1、将发起请求的对象和执行请求的对象解耦，发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁，命令对象会负责让接收者执行请求的动作，也就是说请求发起者和请求调用者之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
2、容易设置一个命令队列，只要把命令对象放入队列，就可以多线程的执行命令。
3、容易实现对请求的撤销和重做。

**坏处**
1、可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候需要主要。

**应用场景**
1、订单的撤销、恢复。
2、触发-反馈机制。



# 59、命令模式在JdbcTemplate中的应用

Spring框架的JdbcTemplate就使用到了命令模式



# 60、访问者模式

**英译**
(Visitor Pattern)

**概述**
1、封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
2、主要将数据结构于数据操作分离，解决数据结构和操作耦合性问题。
3、访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口。
4、访问者模式的应用场景：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决。

**原理图**
1、Visitor：是一个抽象的访问者，为该对象结构中的 ConcreteElement的每一个类声明一个visit操作。
2、ConcreteVisitor：是一个具体的访问者，实现每一个由Visitor声明的操作，是每个操作具体的实现。
3、ObjectStructure：能枚举它的元素，可以提供一个高层的接口用来允许访问者访问它的元素。
4、Element：定义了一个 accept方法，可以接收一个访问者对象。
5、ConcreteElement：为具体的元素，实现了accept方法。

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230328152144519.png" alt="image-20230328152144519" style="zoom:67%;" />

**优点**
1、访问者模式符合单一职责原则，让程序具有优秀的扩展性，灵活性高。
2、访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器、适用于数据结构相对稳定的系统。

**缺点**
1、具体元素对访问者公布细节，也就是说访问者关注了其它类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难。
2、违背了依赖倒转原则，访问者依赖的是具体元素，而不是抽象元素。
3、如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的。



# 61、访问者模式-双分派

所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。
双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型。



# 62、迭代器模式

**英译**
(Interator Pattern)

**概述**
1、迭代器模式是常用的设计模式，属于行为型模式。
2、如果我们的集合元素是用不同的方式实现的，有数组还有java集合类，或者其它方式，当客户端需要遍历这些集合元素时就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
3、迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露内部结构。

**原理图**
1、Iterator：迭代器接口，是系统提供，含有 hashNext、next、remove。
2、ConcreteIterator：具体的迭代器类，管理迭代。
3、Aggreate：一个统一的聚合接口，将客户端和具体聚合解耦。
4、ConcreteAggreate：具体的聚合，持有对象的集合，并提供一个方法可以返回一个迭代器，该迭代器可以正确遍历集合。
5、Client：客户端，通过Iterator和Aggreate依赖子类。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230329090330701.png" alt="image-20230329090330701" style="zoom:67%;" />

**优点**
1、提供了一个统一的方法遍历对象，客户端不再考虑聚合的类型，使用一种方法就可以遍历对象了。
2、隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。
3、提供了一种设计思想，就是一个类应该只有一个引起变化的原因(单一职责原则)。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，之影响到迭代器。
4、当要展示一组相似的对象，或者遍历一组相同对象时 适合使用迭代器模式。

**缺点**
1、每个聚合对象都要有一个迭代器，会生成多个迭代器，不好管理类。





# 63、迭代器模式在ArrayList集合中的应用

**原理图**
1、内部类Itr充当了具体实现Iterator的类，作为ArrayList内部类。
2、List充当了聚合接口，含有iterator()方法，返回一个迭代器对象。
3、ArrayList实现了聚合接口List，实现iterator()方法。
4、iterator接口由系统提供。
5、迭代器模式解决了 ArrayList、LinkedList 统一遍历问题。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230329101231789.png" alt="image-20230329101231789" style="zoom:67%;" />



# 64、观察者模式

**英译**
(Observer Pattern)

**概述**
1、观察者模式：对象之间多对一依赖的一种设计方案，被依赖对象为Subject，依赖的对象为Observer，Subject通知Observer变化，比如牛奶站和用户，奶站是Subject，是1的一方，用户是Observer，是多的一方。



# 65、观察者模式在JDK-Observable类的应用

1、Observable 的作用等价于 Subject
2、Observable 是类，不是接口，类中已经实现了核心方法，即管理 Observer 的方法：add、delete…notify。
3、Observer 的作用就是 Observer(观察者接口)。
4、Observable 的 Observer 使用方法和一般观察者模式一致，具体的Subject可以通过继承 Observable 实现观察者模式。



# 66、中介者模式

**英译**
(Mediator Pattern)

**概述**
1、中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。
2、中介者模式属于行为型模式，利于代码维护。
3、比如SpringMVC，C控制器，M模型，V视图，V就是中介者，在前后端交互时起到了中间人的作用。

**原理图**
1、Mediator：抽象中介者，定义了同事对象到中介者对象的接口。
2、Colleague：是抽象同事类。
3、ConcreteMediator：是具体的中介者对象，实现抽象方法，需要知道所有的具体的同事类，即以一个集合来管理，并接收某个同事对象的消息，完成相应的任务。
4、ConcreteColleague：具体的同事类，会有很多，每个同事只知道自己的行为，而不了解其它同事类的行为。但是它们都含有(依赖)中介者对象。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230329120830674.png" alt="image-20230329120830674" style="zoom:67%;" />

**好处**
1、多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦。
2、减少类间的依赖，减少耦合，符合迪米特法则。

**坏处**
1、中介者承担了较多的责任，一旦中介者出现问题，整个系统就会收到影响。
2、如果设计不当，中介者对象本身变得过于复杂，这点在实际使用中，要特别注意。



# 67、备忘录模式

**英译**
(Memento Pattern)

**概述**
1、备忘录模式：在不破坏封装性的前提下， 捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。
2、现实中的备忘录记录着要去做的事情，或者记录已经达成共同意见的事情，以访忘记，在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作。
3、备忘录模式属于行为型模式。

**角色**
1、originator：对象(需要被保存状态的对象)。
2、Memento：备忘录对象(保存状态的对象)。
3、Caretaker：守护者对象(负责保存多个备忘录对象)。

**好处**
1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史状态。
2、实现了信息的封装，使得用户用户不需要关心状态的保存细节。

**坏处**
1、如果类的成员过多，势必会占用较大的资源，而且每次保存都会消耗一定的内存，需要注意。

**应用场景**
1、后悔药、游戏存档、CTRL+Z、IE中的后退、数据库的事务管理。
2、为了节约内存，备忘录模式可以和原型模式配合使用。



# 68、解释器模式

**英译**
(Interpreter Pattern)

**概述**
1、在编译原理中，一个算术表达式通过 词法分析器 形成词法单元，而后这些词法单元再通过 语法分析器 构建语法分析树，最终形成一棵抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解析器。
2、解析器模式：是指给定一个语言(表达式)，定义它的文法的一种表示，定义一个解释器，使用该解释器来解释语言中的句子(表达式)。

**类图**
1、Context：是环境角色，含有解释器之外的全局信息。
2、AbstractExpression：抽象表达式，声明一个抽象的解释操作，该接口为抽象语法树中所有的节点所共享的。
3、TerminalExpression：为终结符表达式，实现与文法中终结符相关的解释操作。
4、NoTermianlExpression：为非终结符表达式，为文法中的非终结符实现解释操作。
5、说明：输入Context和TerminalExpession信息通过Client输入即可。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230331144656162.png" alt="image-20230331144656162" style="zoom:67%;" />

**好处**
1、当一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性。

**坏处**
1、解释器模式会引起类膨胀，解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。

**应用场景**
1、应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。
2、一些重复出现的问题可以用一种简单的语言来表达。
3、一个简单的语法需要解释的场景。
4、这样的例子如：编译器、运算表达式计算、正则表达式、机器人等。



# 69、解释器模式在Spring框架中的应用

Spring中 SpelExpressionParser 就是解释器模式



# 70、状态模式

**英译**
(State Pattern)

**概述**
1、状态模式：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换。
2、当一个对象的内部状态改变时，允许改变其行为，这个对象看起来像是改变了其类。

**原理图**
1、Context：环境角色，用于维护State实例，定义当前状态。
2、State：抽象的状态角色，定义一个接口，封装与Context的一个特定接口相关的行为。
3、ConcreteState：具体状态角色，每个子类实现一个与Context的一个状态相关行为。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230331160734149.png" alt="image-20230331160734149" style="zoom:67%;" />

**好处**
1、代码有很强的可读性，状态模式将每个状态的行为封装到对应的一个类中。
2、方便维护，将容易产生问题的 else if 语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产生很多 if 语句，而且容易出错。
3、符合开闭原则，容易增删状态。

**坏处**
1、会产生很多类，每个状态都要用到一个对应的类，增加维护难度。

**使用场景**
当一个事件或者对象拥有很多状态时，状态之间会相互转换，对不同的状态要求有不同行为时，可以考虑使用状态模式。



# 71、策略模式

**英译**
(Strategy Pattern)

**概述**
1、策略模式中，定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
2、这种算法体现了几个设计原则：
		第一、把变化的代码从不变的代码中分离出来。
		第二、针对接口编程，而不是具体类(定义了策略接口)。
		第三、多使用组合、聚合，少使用继承(客户端通过组合方式使用策略模式)。

**原理类图**
1、客户Context有成员变量StrategyA、StrategyB(都是策略接口) 或者其它的策略接口，至于需要使用到哪个策略，可以在构造器中指定

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230401130428197.png" alt="image-20230401130428197" style="zoom:67%;" />

**注意细节**
1、策略模式的关键：分析项目中变化部分与不变部分。
2、策略模式的核心思想：多使用组合/聚合，少用继承；用行为类组合，而不是行为的继承，更有弹性。

**好处**
1、体现了"对修改关闭，对扩展开放"原则，客户端增加行为不用修改原有代码，只要添加一种策略(或者行为)即可，避免了使用多重转移语句(if…else if)
2、提供了可以替换继承关系的办法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。

**缺点**
1、每添加一个策略就需要新增一个类，当策略过多时会导致类数目庞大。



# 72、策略模式在Arrays中的应用

jdk中Arrays的Comparator就使用到了策略模式



# 73、职责链模式

**英译**
(Chain of Responsibility Pattern)

**概述**
1、职责链模式又叫 责任链模式，为请求创建一个接收者对象的链(简单示意图)。这种模式对请求的发送者和接收者进行解耦。
2、职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，以此类推。
3、这种类型的设计模式属于 行为型模式。

**原理类图**
1、职责链模式 使得多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
2、Handler：抽象的处理者，它定义了一个处理请求的接口，同时含有另外一个Handler。
3、ConcreteHandlerA/B：具体的处理者，处理它自己负责的请求，可以访问它的后继者(即下一个处理者)，若可以处理当前请求，则处理，否则将该请求交给后继者处理，从而形成一个职责链。
4、Request：含有多个属性，表示一个请求。
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230401142328672.png" alt="image-20230401142328672" style="zoom:67%;" />

**好处**
1、将请求和处理分开，实现解耦，提高系统灵活性。
2、简化了对象，使用对象不需要直到链的结构。

**缺点**
1、性能会收到影响，特别是在链比较长的时候，因此需要控制链中最大节点数量，一般通过Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阈值，超过则不允许该链建立，避免出现超长链无意识的破坏系统性能。
2、调试不方便，采用递归方式，调试时逻辑可能比较复杂。

**使用场景**
1、有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪 等审批流程、Javaweb中Tomcat对Encoding的处理、拦截器。



# 74、职责链模式在Spring-MVC框架的应用

SpringMVC-HandlerExecutionChain 类使用了职责链模式。
1、springmvc 请求的流程中，执行了 拦截器相关方法 interceptor.preHandler 等等
2、在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式
3、HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程
4、HandlerExecutionChain 维护了 Handlerlnterceptor 的集合， 可以向其中注册相应的拦截器。

































