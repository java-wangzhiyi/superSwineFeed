> 互联网的本质就是一系列的网络协议

**0到1带你理解网络**

### 网络到分布式

> * TCP/IP
> * socket
> * OIO
> * BIO
> * NIO
> * epoll
> * redis
> * kafka
> * pocketMQ
> * handler
> * pools
> * Kernel
> * OS IO
> * RPC
> * Netty

### 1. OSI七层协议

![网络协议](%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.assets/fbfe5cd673914f31afa4ad8dc137993d.png)

> OSI七层协议: 比较完整,但是既复杂又不实用.
> TCP/IP协议: 则不同,他现在已经得到了非常广泛的应用.
> 五层协议: 采用折中的方式,既简洁又能将概念阐述清楚.
>
> 实质上,以程序员的角度来讲,,TCP分为2层. 应用 和 操作系统内核.我们只需要关注应用层即可.

| OSI层      | 功能                                     | 协议                        |
| ---------- | ---------------------------------------- | --------------------------- |
| 应用层     | 文本传输，电子邮件，文件服务，虚拟终端等 | FTP,HTTP,SNMP,DNS等         |
| 表示层     | 数据格式化，代码转换，数据加密           | 没有协议                    |
| 会话层     | 解除或建立与其他节点的联系               | 没有协议                    |
| 传输层     | 提供端对端的接口                         | TCP,UDP                     |
| 网络层     | 为数据包选择路由                         | IP,ICMP,RIP,OSPF,BGP,IGMP   |
| 数据链路层 | 传输有地址的帧，错误检测功能             | SLIP,CSLIP,PPP,ARP,RARP,MTU |
| 物理层     | 以二进制数据形式在物理媒体上传输数据     | ISO2110,IEEE802,IEEE802.2   |



### 2. TCP

> 面向连接的,可靠的传输协议

##### 三次握手

* 客户端向服务端发送数据包 发送一个 syn
* 服务端向客户端发送一个 syn + ack 确认收到客户端的数据包
* 客户端向服务端发送 ack 确认

> 三次握手之后,客户端和服务器会**开辟对应的资源**. 资源即连接,三次握手之间只是数据包的传输,没有进行物理连接.
> 三次握手之后会以**Socket**形式交付给程序/进程.

> 如果三次握手之后,服务端挂掉,则客户端是无感知的.
> 因此,我们了解的中间件也好,CS软件也好,通常会有一个心跳机制(存活检测)



##### Socket

* 文件描述服务
* 插座 套接字

> **问:**	什么是套接字
> 是套接字,套接字是什么? **包含了 元IP+PORT + 目标IP+PORT**,且具备唯一性.
>
> **问:**	A服务器能不能同时使用相同的端口号去连接其他主机上的服务
> TCP/IP 协议支持此动作, centos上的nc软件不支持, 但是 java中new Socket().setReuseAddress(true) 方法可以设置同一服务器上的多个程序使用相同端口号与其他主机上的程序建立Socket连接.
>
> **问:**	centos内核支持reuse吗?为什么?
> 支持,但是需要设置,默认是不开启的,原因就是当socket连接断开时,在内核中不会立即释放,开启reuse可能会造成冲突.
>
> **问:**	centos中查看连接的命令是什么?
> netstat -natp
> ss -na

##### Recv-Q

> 已经建立连接,但是未分配进程接管该socket的队列

##### Sent-Q

> 发送队列



##### 网络IO

> **问:**	所谓的网络IO的读写,指的是什么?
> 指的是读写操作系统内核中Socket的queue.
>
> **问:**	IO模型指的七层中的哪一层
> 具体指的是应用层和kernal相连接的那一层.
>
> **问:**	程序的IO模型怎么分辨?
> 在内核读取不到socket中Recv-Q中的数据时(读取队列没有数据),内核的表现形式,决定了程序面向操作系统的IO模型是什么

##### BIO

> 进程之间的socket连接建立之后,内核从Recv-Q中获取数据提供给程序,当Recv-Q中没有任何数据时,阻塞该socket,程序即阻塞

##### NIO

> 同上,但是若Recv-Q中没有数据,会给程序发送一个0或者NULL表示无数据,而不是阻塞

##### 多路复用器 epoll

> 服务器上有很多连接,程序想要获取哪些socket有数据包发送过来,则会调用内核的方法来获取哪些连接有数据,哪些没有.



#### 四次挥手

> 断开的目的,双方释放资源

* 客户端向服务器发起: FIN
* 服务器向客户端确认: FIN ACK
* 服务器向客户端发起: FIN
* 客户端向服务器确认: ACK

> **centos 抓包工具**
> tcpdump -nn -i eth0 port 80





### 3. 网络层

##### IPADDR

IPV4 唯一IP,32位2进制值,每节8位,以.分隔,为了方便使用,每一节通过十进制表示.

> 1010 1000.0000 0000.0000 0000.0000 0001
> 168.0.0.1



##### **NETMASK** 

子网掩码,一个应用于TCP/IP网络的32位二进制值,每节8位,以.分隔,每节通过十进制表示,必须结合IP地址使用
子网掩码32位与IP地址32位二进制数一一对应,若某位是网络地址,则子网掩码为1,否则为0
子网掩码可以通过与IP地址按位与计算,分离出IP地址中的网络地址和主机地址,用于判断该IP是在广域网还是者局域网上
子网掩码一般用于将网络进一步划分为若干子网,以避免主机过多而拥堵或主机过少而浪费.
子网掩码可以分离出IP地址中的网络地址和主机地址，那为什么要分离呢？因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地,即路由器。

> ​					IPV4																							子网掩码
> 二进制位	1010 1000.0000 0000.0000 0000.0000 0001						1111 1111.1111 1111.1111 1111.0000 0000
> 简化			168.0.0.1																					 255.255.255.0



##### GATEWAY

网关,广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地,即GATEWAY.



##### DNS1

域名解析服务器,用于解析 www.xxx.xxx 等域名为IP



##### router

> [root@docker01 ~]# route -n
> Kernel IP routing table
> Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
> 0.0.0.0         172.23.143.253  0.0.0.0         UG    0      0        0 eth0
> 169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
> 172.23.128.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0

路由规则,以上命令会显示路由规则,控制台显示的规则表示, 169.254 和 172.23.128开头的IP,不需要经过Gateway,数据包可直接发送.怎么匹配的?
讲目标IP与Genmask做按位与操作(有0则0,全1则1),得到的结果和Destination 比较,相等则扔给这个网关,如果网关是0.0.0.0,则直接发送数据包.



##### 思考

如果要向 16.4.123.10 发送数据包,网络层通过路由规则知道了该通过 172.23.143.253 进行跳转,但是两个IP的网络地址是不一样的,两个IP怎么建立连接呢?





### 4. 链路层

##### mac地址

> Media Access Control Address ,以太网地址/物理地址
> 用来确定网络设备互联网位置



##### arp协议

> 地址解析协议,是根据IP地址获取物理地址的一个TCP/IP协议.
>
> [root@docker01 ~]# arp -a
> gateway (172.23.143.253) at ee:ff:ff:ff:ff:ff [ether] on eth0
> master01.cbdi.ccc.cib (172.23.130.54) at ee:ff:ff:ff:ff:ff [ether] on eth0
> app01.cbdi.ccc.cib (172.23.130.57) at ee:ff:ff:ff:ff:ff [ether] on eth0
> docker02 (172.23.130.44) at ee:ff:ff:ff:ff:ff [ether] on eth0

* 向目标IP发送数据包, 如果不在目标地址和当前主机地址的网络地址不同 ,则需要走路由器, 则当前主机就会向路由器发送一个 包含 **arp协议 + 目标IP + 端口号 + 路由器/主机物理地址 ** 的数据包.
* A 路由器接收到该数据包,会撕毁该数据包内的 **路由器/主机物理地址**,  经过自己的路由表判定 **目标IP** 走哪个路由器 B, 将 B 的 **路由器/主机物理地址** 封装进数据包内, 并将该数据包发送给 B
* B 收到后做 A 同样的事情 …
* 就这样,一直找到 数据包内 **目标IP 和 路由器/主机物理地址** = 就是该路由器/主机后, 判定这个数据包就是他要解析的,于是开始拿**端口** 和 包内的**字节数据**解析要做的事情.

发现一个特点,在数据包 `发送 >> 路由 >> 路由 >> … >> 最后服务器操作` 的过程中, 目标IP是不变的,变的是MAC地址.
IP地址是网络层的, 而一个路由指向另一个路由,这个过程类似于数据结构中的链表,因此,这个过程的层级为 **链路层**



### 5. TCP 面试题

服务调用中使用一个Socket好还是多个Socket好

>  不存在一个或者多个好的情况,如果有多个程序占用不同的端口,那么就是多个Socket.



CAP 中的P是什么意思,为什么只能CP和AP

> CAP理论.C指的一致性,A可用性,P分区容忍性.
> AP还是CP具体看使用场景,如果是金融支付等必须保证数据强一致性的行业,那么CP,如果行业要求实时性高于数据一致性,那么AP



一台主机可以创建多少个Socket连接

> 如果当前主机要和外界建立连接, 端口号和IP决定了能建立多少Socket, 理论上可以创建 65535 * n(主机+端口组合)



程序GC对Socket是否有影响

> GC是程序暂停
> Socket是内核接管的



TCP不建立三次握手能否处理数据包

> 能,在服务端收到ack之前的2次握手后,客户端可以向服务端发送数据包





### 6. IO模型

##### 程序是怎么运行的

> 计算机在启动的时候,会加载内核程序到内存中,内核和CPU进行交互,我们的程序是通过SystemCall(系统调用的方式)跟计算机内核程序交互以操纵CPU.
> 多个程序是多个进程,多个程序同时执行有时钟中断的逻辑保证不同线程都会执行



##### IO模型的成本,为什么有BIO,NIO,OIO,EPOLL,AIO

> 更少的触发系统调用,减少浪费, 为什么有这么多的IO模型,其实就是程序员修改bug的过程



##### 什么是进程什么是线程

> 进程是一个容器,包裹着线程,线程是CPU调度和分派的基本单位



#### BIO

> 阻塞类IO





#### NIO

linux内核 epoll_create 源码







#### AIO

HKEY_CLASSES_ROOT\ftp\shell\open\command



#### epoll

> 针对对应事件响应的channel
> 基于事件响应





### redis线程模型

